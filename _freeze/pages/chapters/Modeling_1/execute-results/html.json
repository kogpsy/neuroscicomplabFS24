{
  "hash": "43d395b42213ee6cac1c351918c400f4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Einf√ºhrung\"\nauthor:\n  - name: Daniel Fitze\n    # url: https://github.com/awellis\n    affiliation: Kognitive Psychologie, Wahrnehmung und Methodenlehre, Universit√§t Bern \n    affiliation-url: https://www.kog.psy.unibe.ch\n    orcid: 0000-0003-0158-7459  \n  - name: Gerda Wyssen\n    # url: https://github.com/awellis\n    affiliation: Kognitive Psychologie, Wahrnehmung und Methodenlehre, Universit√§t Bern \n    affiliation-url: https://www.kog.psy.unibe.ch\n    orcid: 0000-0001-7427-3149\nlicense: CC BY-SA 4.0\ncitation: true\nbibliography: ../../bibliography.bib\nformat:\n    html:\n        toc: true\n---\n\n::: {.cell}\n\n:::\n\n\nUns interessiert, wie Daten entstanden sind. Wir k√∂nnen Daten deskriptiv beschreiben. Aber auch da haben wir bereits ein Vorstellung vom Prozess, der die Daten generiert hat. Das Ziel ist es, von den Daten zu lernen, sie zu beschreiben, vorherzusagen und zu erkl√§ren.  \n\n# Planetare Bewegung\n:::: {layout=\"[ 50, 50 ]\"}\n\n::: {#first-column}\n\n### Beobachtung/Daten:\n- Position der Planeten am Himmel √ºber die Zeit\n- Einige Planeten √§nderen pl√∂tzlich ihre Richtung\n- Nach einiger Zeit nehmen sie ihren urspr√ºnglichen Weg wieder auf\n\n:::\n\n::: {#second-column}\n\n![](img/planet_motion.png)\n\n:::\n::::\n\n:::: {layout=\"[ 50, 50 ]\"}\n\n::: {#first-column}\n\n### Geozentrisches Modell\n\n![](img/geo_centric.png)\n\n:::\n\n::: {#second-column}\n\n### Heliozentrisches Modell\n\n![](img/helio_centric.png)\n\n:::\n::::\n\nüëâ Die Daten lassen sich nur mit einem Modell des zugrunde liegenden  Prozesses erkl√§ren\n\nüëâ Modelle an sich k√∂nnen nicht beobachtet werden\n\nüëâ Es gibt fast immer mehrere Modelle, welche die Daten erkl√§ren k√∂nnen\n\n\n\n# Daten generierender Prozess\n\nIm Beispiel oben versuchen wir anhand der Daten heraus zu finden, wie das Universum aufgebaut ist. Wir verwenden ein Modell um Informationen aus den Daten zu gewinnen. Wechseln wir nun zu einem etwas einfacheren Beispiel. \nStellen Sie sich vor wir werfen einen Stein. Die Endposition des Steins h√§ngt von den Kr√§ften ab, die auf den Stein wirken.\n\n![ [Bildquelle](https://etc.usf.edu/clipart/36300/36322/proj_mot_36322.htm)](img/stone_throw.png)\n\n## Verbales Modell\nBeginnen wir mit einem verbalen Modell von diesem Prozess. Die Endposition des Steins h√§ngt von der Kraft und der Richtung (Input) des Wurfs ab. Faktoren wie z.B. der Luftwiderstand oder die Gravitationskraft ber√ºcksichtigen wir vorerst nicht in unserem Modell, da sie konstant sind.\n\n:::: {layout=\"[ 50, 50]\"}\n\n:::{}\n\n\n```{mermaid}\n%%| fig-align: center\nflowchart TD\n  i((Input)):::A --> p((Position)):::B\n  \n  classDef A fill:#ffffff, r:40px\n  classDef B fill:#e5e4e4\n```\n\n\n:::\n\n:::{}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Modeling_1_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n:::\n\n::::\n\n\n:::callout-caution\n## Hands-on: Simulation verbales DAG\n\nDen Prozess, der durch das verbale DAG beschrieben wird, wiederholen wir 10 Mal. Der Input bleibt konstant. Bei jeder Durchf√ºhrung notieren wir die Endposition des Steins.\n\n1. √úberlegen Sie sich, wie diese Daten aussehen.\n\n2. Simulieren (generieren) Sie diese Daten in R.\n\n3. Machen Sie eine sinnvolle Abbildung der simulierten Daten.\n\n:::\n\n\n## Statistisches Modell\nBer√ºcksichtigen wir nun, dass der Stein von einer Person geworfen wird.\nDie Person zielt immer auf die gleiche Stelle (Œº). \nEs ist aber unm√∂glich den Stein jedes Mal exakt gleich zu werfen. \nEs gibt also eine gewisse Variation der beobachteten Endpositionen (œÉ).\n\n:::: {layout=\"[ 50, 50 ]\"}\n\n:::{}\n\n\n\n```{mermaid}\nflowchart TD\n  mu((Œº)):::a --> i((Input)):::A\n  s((œÉ)):::a --> i\n  i((\"Input \\n N(Œº,œÉ)\")):::A --> p((Position)):::B\n\n  classDef a fill:#ffffff, r:20px\n  classDef A fill:#ffffff, r:40px\n  classDef B fill:#e5e4e4\n```\n\n\n:::\n\n:::{}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Modeling_1_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n:::\n\n::::\n\n\n:::: {layout=\"[ 50, 50 ]\"}\n\n::: {#first-column}\n\n\n\n:::\n\n::: {#second-column}\n\n\n:::\n::::\n\n:::callout-caution\n## Hands-on: Simulation\n\nDen Prozess, der durch das (statistische) DAG beschrieben wird, wiederholen wir 10 Mal. Der Input ist nun normal verteilt. Bei jeder Durchf√ºhrung notieren wir die Endposition des Steins.\n\n1. √úberlegen Sie sich, wie diese Daten aussehen.\n\n2. Simulieren (generieren) Sie diese Daten in R.\n\n3. Machen Sie eine sinnvolle Abbildung der simulierten Daten.\n\n:::\n\n\n### Simulation vs. Inferenz\n\n\n![](img/sim_inf.png){fig-align=\"center\" width=650}\n\n\n:::: {layout=\"[ 50, 50 ]\"}\n::: {#first-column}\n### Simulation\nWir w√§hlen Werte f√ºr die Modell-Parameter:\n\n::: {.cell}\n\n```{.r .cell-code}\nmu = 5\nsigma = 0.2\n```\n:::\n\n\nDamit k√∂nnen wir Daten simulieren:\n\n::: {.cell}\n\n```{.r .cell-code .code-overflow-scroll}\nsim_data = tibble(\n    pos = rnorm(n = 10, mu, sigma)\n    )\n\nhead(sim_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 √ó 1\n    pos\n  <dbl>\n1  4.89\n2  4.84\n3  4.90\n4  4.68\n5  4.97\n6  5.16\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {#second-column}\n### Inferenz (Parametersch√§tzung)\nWir beginnen mit Daten. Die Modell parameter sind uns nicht bekannt.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 √ó 1\n      x\n  <dbl>\n1  4.39\n2  4.22\n3  4.39\n4  4.18\n5  4.36\n6  4.30\n```\n\n\n:::\n:::\n\n\nBasierend auf dem DAG formulieren wir ein lineares Modell. In diesem Fall sch√§tzen wir nur den Intercept. Mit der Funktion `lm()` k√∂nnen wir die Parameter von diesem Modell sch√§tzen (frequentistisch).\n\n::: {.cell}\n\n```{.r .cell-code}\nfit = lm(x ~ 1,\n         data = d)\n\ncoef(fit)[\"(Intercept)\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(Intercept) \n   4.289853 \n```\n\n\n:::\n\n```{.r .cell-code}\nsigma(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.08287332\n```\n\n\n:::\n:::\n\n\n:::\n::::\n\n### Kategorialer Pr√§diktor - Planet\n\n:::: {layout=\"[ 50, 50 ]\"}\n:::{}\n\n\n```{mermaid}\nflowchart TD\n  g((Gravitation)):::A --> p((Position)):::B\n  i((Input)):::A --> p\n  \n  classDef A fill:#ffffff, r:40px\n  classDef B fill:#e5e4e4\n```\n\n:::\n\n:::{}\nIn diesem Fall haben wir die Endposition auf der Erde und auf dem Mond gemessen.\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 √ó 2\n  planet   pos\n  <chr>  <dbl>\n1 erde    5.00\n2 erde    5.35\n3 erde    5.10\n4 mond    7.53\n5 mond    7.09\n6 mond    6.98\n```\n\n\n:::\n:::\n\n:::\n::::\n\n\n::: {.cell}\n\n:::\n\n\nHier f√ºgen wir dem linearen Modell einen kategorialen Pr√§diktor hinzu und sch√§tzen die Parameter mit der Funktion `lm()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nlm(pos ~ 1 + planet,\n   data = d_cat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = pos ~ 1 + planet, data = d_cat)\n\nCoefficients:\n(Intercept)   planetmond  \n      4.951        2.055  \n```\n\n\n:::\n:::\n\n\n### Kontinuierlicher Pr√§diktor - K√∂rpergr√∂sse\n\n:::: {layout=\"[ 50, 50 ]\"}\n:::{}\n\n\n```{mermaid}\nflowchart TD\n  g((K√∂rpergr√∂sse)):::A --> p((Position)):::B\n  i((Input)):::A --> p\n  \n  classDef A fill:#ffffff, r:40px\n  classDef B fill:#e5e4e4\n```\n\n:::\n\n:::{}\nHier interessiert uns der Einfluss der K√∂rpergr√∂sse auf die Endposition eines geworfenen Steins. \n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 √ó 2\n  gr√∂sse   pos\n   <dbl> <dbl>\n1    165  5.21\n2    165  4.82\n3    165  5.35\n4    170  5.72\n5    170  6.01\n6    170  6.33\n```\n\n\n:::\n:::\n\n:::\n::::\n\n\n::: {.cell}\n\n:::\n\n\nHier f√ºgen wir dem linearen Modell einen kontinuierlichen Pr√§diktor hinzu und sch√§tzen die Parameter mit der Funktion `lm()`.\n\n::: {.cell}\n\n```{.r .cell-code}\nlm(pos ~ 1 + gr√∂sse,\n   data = d_cont)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = pos ~ 1 + gr√∂sse, data = d_cont)\n\nCoefficients:\n(Intercept)       gr√∂sse  \n   -30.1571       0.2133  \n```\n\n\n:::\n:::\n\n\n:::callout-caution\n## Hands-on: Parameter Recovery\n\nMit parameter recovery kann √ºberpr√ºft werden, wie gut die Parameter des Modells gesch√§tzt werden k√∂nnen. Dazu werden zu erst Daten simuliert. In der anschliessenden Analyse der Daten sieht man wie nahe die gesch√§tzten Parameter den wahren (in der Simulation verwendeten) sind.\n\n1. Entscheiden Sie sich f√ºr ein Modell mit einem kategorialen oder einem kontinuierlichen Pr√§diktor.\n\n2. Simulieren (generieren) Sie die entsprechenden Daten in R.\n\n3. Analysieren Sie die Simulierten Daten mit dem entsprechenden Modell. \n    - Wie nahe ist die Sch√§tzung an den wahren Parametern? \n    - Von welchen Faktoren k√∂nnte das abh√§ngen?\n\n:::\n\n\n<!-- ## Ausblick Modell f√ºr RD-Motion  -->\n\n<!-- :::: {layout=\"[ 50, 50 ]\"} -->\n<!-- :::{} -->\n\n<!-- ```{mermaid} -->\n<!-- flowchart TD -->\n<!--   g((Sensitivit√§t)):::A  p((Antwort)):::B -->\n\n<!--   classDef A fill:#ffffff, r:40px -->\n<!--   classDef B fill:#e5e4e4 -->\n<!-- ``` -->\n<!-- ::: -->\n\n<!-- :::{} -->\n<!-- {{< video https://www.youtube.com/watch?v=7OdCe95IiLw >}} -->\n<!-- ::: -->\n<!-- :::: -->\n\n",
    "supporting": [
      "Modeling_1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}