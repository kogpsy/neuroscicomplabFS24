{
  "hash": "e75d7a72068f45d60fef625f39613576",
  "result": {
    "markdown": "---\ntitle: \"Automatisiertes importieren und vorverarbeiten\"\ndescription: \"\"\nexecute:\n  output: false\nauthor:\n  - name: Daniel Fitze\n    affiliation: Kognitive Psychologie, Wahrnehmung und Methodenlehre, Universität Bern \n    affiliation-url: https://www.kog.psy.unibe.ch\n    orcid: 0000-0003-0158-7459  \n  - name: Gerda Wyssen\n    affiliation: Kognitive Psychologie, Wahrnehmung und Methodenlehre, Universität Bern \n    affiliation-url: https://www.kog.psy.unibe.ch\n    orcid: 0000-0001-7427-3149\nlicense: CC BY\ncitation: true\nbibliography: ../../bibliography_nsci24.bib\nformat:\n    html:\n        toc: true\n        code-link: true\n---\n\n\n\n\nFür diesen Teil benötigen Sie das _R-Project_ `complab_datawrangling_stroop` mit den 3 von Ihnen erhobenen Datensätzen des Stroop Experiments.\n\n## Setup\n\n\n::: {.cell warnings='false' errors='false' hash='datawrangling_automatisiert_cache/html/unnamed-chunk-2_04323d7cb0e21c4adf7e4c8bd1cf9dbc'}\n\n```{.r .cell-code}\n# Package laden (bei jedem Öffnen von R zu Beginn des Skripts ausführen)\nlibrary(\"tidyverse\") \n```\n:::\n\n\n## **Stroop-Experiment** data wrangling\n\n\n::: {.cell hash='datawrangling_automatisiert_cache/html/unnamed-chunk-3_c0e712608386b312ebf5833c9b1da5e0'}\n\n```{.r .cell-code}\n# Daten vorverarbeiten\nd_stroop = read_csv(\"data/stroop_example_1.csv\") |>\n    filter(!is.na(trials_test.thisN)) |>\n    mutate(trial = trials_test.thisN + 1) |>\n    select(id = participant, \n           trial,\n           word, \n           color, \n           congruent, \n           resp = keyResp_test_run.keys, \n           corr = keyResp_test_run.corr, \n           rt = keyResp_test_run.rt)\n```\n:::\n\n\n\n## Daten mit eigener [Funktion](https://kogpsy.github.io/neuroscicomplabFS24/pages/chapters/programmieren_2.html#funktionen) einlesen\n\n\n::: {.cell hash='datawrangling_automatisiert_cache/html/unnamed-chunk-4_8f415ee720d5164d01c1fc6c302dbdab'}\n\n```{.r .cell-code}\nread_stroop = function(path){\n    # Code kopiert von oben\n    d_stroop = read_csv(path) |>\n    filter(!is.na(trials_test.thisN)) |>\n    mutate(trial = trials_test.thisN + 1) |>\n    select(id = participant, \n           trial,\n           word, \n           color, \n           congruent, \n           resp = keyResp_test_run.keys, \n           corr = keyResp_test_run.corr, \n           rt = keyResp_test_run.rt)\n    # ---------------------\n    d_stroop\n}\n\nread_stroop(path = \"data/stroop_example_1.csv\")\n```\n:::\n\n\n## Einlesen Automatisieren\n\nWir benötigen eine Liste aller Daten files. Die Funktion `list.files()` gibt einer liste aller Dokumente in einem Ordner zurück.\n\n::: {.cell hash='datawrangling_automatisiert_cache/html/unnamed-chunk-5_38ab823ac51f50b3c077f65d2566d15e'}\n\n```{.r .cell-code}\nlist.files(path = 'data/')\n\nlist.files(path = 'data/', pattern = 'stroop')\n```\n:::\n\nUm die Files einzulesen, reichen nur die Namen der Dateien nicht aus. Dazu benötigen wir die kompletten Pfade.\n\n::: {.cell hash='datawrangling_automatisiert_cache/html/unnamed-chunk-6_d88e59e79b4b20e46272c4194ca1fb98'}\n\n```{.r .cell-code}\nfiles = list.files(path = 'data/', pattern = 'stroop') %>% \n    paste('data/', ., sep = '')\n```\n:::\n\n\n### Alle Files von Hand einlesen\nJedes Daten File wird einzeln eingelesen. Anschliessend müssen alle Files zusammengefügt werden. Diese Lösung ist einfach zu verstehen, ist bei vielen Dokumenten aber zu aufwändig.\n\n::: {.cell hash='datawrangling_automatisiert_cache/html/unnamed-chunk-7_9dc8ab0d2f7894d2cd965c3876cc7c55'}\n\n```{.r .cell-code}\nfile1 = files[1]\nfile2 = files[2]\nfile3 = files[3]\n\nd1 = read_stroop(file1)\nd2 = read_stroop(file2)\nd3 = read_stroop(file3)\n\nd_hand = bind_rows(d1, d2, d3)\n```\n:::\n\n\n### Alle Files mit `for`-Loop einlesen\nDas Einlesen kann mit einem for-Loop automatisiert werden. Der Loop iteriert über alle Daten Files. Als erstes muss ein leerer Data Frame `d_loop` erstellt werden. Bei jeder Iteration des Loops wird ein Daten File eingelesen und dem erstellten Data Frame `d_loop` angehängt.\n\n::: {.cell hash='datawrangling_automatisiert_cache/html/unnamed-chunk-8_97384842b6dd46c387b1e85228bb8f9a'}\n\n```{.r .cell-code}\nd_loop = tibble()\n\nfor (file in files){\n    d_tmp = read_stroop(file)\n    d_loop = bind_rows(d_loop, d_tmp)\n}\n```\n:::\n\n\n### Alle Files mit der Funktion `map()` einlesen\n`map()` wendet eine Funktion auf alle Elemente eines Vektors an. Der Vektor `files` enthält die Pfade zu den Daten Files. Mit `map()` können wir also unsere selbst erstellte Funktion `read_stroop()` auf jeden Pfad anwenden. Im Anschluss müssen die Dataframes noch verbunden werden. \n\n::: {.cell hash='datawrangling_automatisiert_cache/html/unnamed-chunk-9_61036874b73026f912bcced1e595a1c8'}\n\n```{.r .cell-code}\nd_map1 = files |>\n    map(read_stroop) %>%\n    bind_rows()\n```\n:::\n\n\nDie Funktion `map_dfr()` macht das gleiche wie `map()` fügt aber zusätzlich die einzelnen Data Frames automatisch zusammen.\n\n::: {.cell hash='datawrangling_automatisiert_cache/html/unnamed-chunk-10_15db8e38ad421086588c1465dc12b1fd'}\n\n```{.r .cell-code}\nd_map2 = files |>\n    map_dfr(read_stroop)\n```\n:::\n\n\n## Kompletter Stroop Code an einem Ort\n\n\n::: {.cell hash='datawrangling_automatisiert_cache/html/unnamed-chunk-11_68756dc499ae0bef36f40a783d11a380'}\n\n```{.r .cell-code}\nread_stroop = function(path){\n    d_stroop = read_csv(path) |>\n    filter(!is.na(trials_test.thisN)) |>\n    mutate(trial = trials_test.thisN + 1) |>\n    select(id = participant, \n           trial,\n           word, \n           color, \n           congruent, \n           resp = keyResp_test_run.keys, \n           corr = keyResp_test_run.corr, \n           rt = keyResp_test_run.rt)\n    d_stroop\n}\n\nd = list.files(path = 'data/', pattern = 'stroop') %>% \n    paste('data/', ., sep = '') |>\n    map_dfr(read_stroop)\n\nd |> write.csv(file = \"data/dataset_stroop_clean.csv\", row.names = FALSE)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}