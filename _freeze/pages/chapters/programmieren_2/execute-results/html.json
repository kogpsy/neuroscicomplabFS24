{
  "hash": "93fc776f9051b8e6ce4b5a4badc71a52",
  "result": {
    "markdown": "---\ntitle: \"Automatisieren\"\ndescription: Ein Exkurs zu den Themen Conditionals, Funktionen und Loops.\n# date: \"2023-03-20\"\nauthor:\n  - name: Daniel Fitze\n    # url: https://github.com/awellis\n    affiliation: Kognitive Psychologie, Wahrnehmung und Methodenlehre, Universität Bern \n    affiliation-url: https://www.kog.psy.unibe.ch\n    orcid: 0000-0003-0158-7459  \n  - name: Andrew Ellis\n    url: https://github.com/awellis\n    affiliation: Kognitive Psychologie, Wahrnehmung und Methodenlehre, Universität Bern \n    affiliation-url: https://www.kog.psy.unibe.ch\n    orcid: 0000-0002-2788-936X\nlicense: CC BY\ncitation: true\nbibliography: ../../bibliography.bib\nformat:\n    html:\n        toc: true\n        code-link: true\nexecute: \n  cache: false\n---\n\n\n:::{.callout-tip collapse=\"false\"}\n## Lernziele\n\nIn der heutigen Sitzung lernen wir:\n\n- Conditionals und Control Flow\n- Funktionen erstellen\n- Loops anwenden\n\nFühren Sie die folgenden Code Beispiele auf Ihrem Computer aus. Wenn Sie R und RStudio noch nicht installiert haben, verwenden Sie diese [online R Konsole](https://www.programiz.com/r/online-compiler/).\n:::\n\n\n\n\n\nWir lernen nun zwei Programmierkonzepte kennen, die uns dabei helfen, Tasks zu automatisieren. Wir werden hier nicht in die Tiefe gehen; es geht uns vielmehr darum, Ihnen einen Überblick zu geben, was Sie mit diesen Konzepten machen können. Falls Sie tiefer in die Materie einsteigen möchten, gibt es entsprechende Kurse auf Datacamp.\n\n\n:::{.callout-caution collapse=\"true\"}\n## Datacamp\n- Falls Sie eine Einführung in Programmierkonzepte (Conditionals and Control Flow, Functions, Loops) benötigen, empfehlen wir Ihnen den Datacamp Kurs [Intermediate R](https://app.datacamp.com/learn/courses/intermediate-r).\n:::\n\n\n# Conditionals und Control Flow\n\nConditionals und Control Flow sind Konzepte, die es uns ermöglichen, den Programmablauf zu steuern. Wir können damit zum Beispiel entscheiden, ob ein bestimmter Codeblock ausgeführt wird oder nicht. Wir können auch den Programmablauf abhängig von bestimmten Bedingungen steuern. Dies ist nützlich, wenn wir zum Beispiel eine bestimmte Aktion nur dann ausführen wollen, wenn eine Bedingung erfüllt ist.\n\n:::{.callout-tip collapse=\"true\"}\n## Logische Operatoren\nUm Bedingungen zu testen werden verschiedene logische Operatoren verwendet.\n\n| Definition     | Operator |\n|:--------------:|:--------:|\n| gleich wie     | ==       |\n| nicht gleich   | !=       |\n| kleiner als    | <        |\n| kleiner gleich | <=       |\n| grösser als    | >        |\n| grösser gleich | >=       |\n:::\n\nAls simples Beispiel wollen wir eine Zahl `x` definieren und prüfen, ob diese grösser als 0 ist. Wenn ja, dann wollen wir die Zahl ausgeben. Wenn nein, dann wollen wir eine Fehlermeldung ausgeben. Um diesen Test `x > 0` auszuführen, können wir `if` verwenden. `if` testet, ob eine Bedingung wahr ist. Falls ja, wird ein Codeblock ausgeführt. Der Codeblock wird in geschweiften Klammern `{}` eingeschlossen. Wenn die Bedingung nicht erfüllt ist, dann wird der Codeblock nicht ausgeführt. Falls die Bedingung nicht wahr ist, können wir eine Alternative mit `else` angeben. Der Codeblock, der ausgeführt wird, wenn die Bedingung nicht wahr ist, wird ebenfalls in geschweiften Klammern `{}` eingeschlossen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nif (x > 0) {\n  print(x)\n} else {\n  print(\"x is not greater than 0\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n\n\n:::{.callout-important}\nÄndern sie den Wert von `x` und führen Sie den Codeblock erneut aus. Was passiert, wenn `x` negativ ist?\n:::\n\n\n\nWir können nun auch mehrere Bedingungen testen. Dazu verwenden wir `if`, `else if` und `else`. `else if` ist eine Alternative zu `else`, wenn die erste Bedingung nicht wahr ist. `else if` wird  dann ausgeführt, wenn die erste Bedingung nicht wahr war. `else` wird nur dann ausgeführt, wenn alle vorherigen Bedingungen nicht wahr waren.\n\nZum Beispiel wollen nun ebenfalls prüfen, ob `x` gleich 0 ist. Falls ja, dann wollen wir eine andere Fehlermeldung ausgeben. Falls nein, dann wollen wir die Fehlermeldung ausgeben, die wir bereits definiert haben.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (x > 0) {\n  print(x)\n} else if (x == 0) {\n  print(\"x is 0\")\n} else  {\n    print(\"x is not greater than 0\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\n:::{.callout-important}\nÄndern sie den Wert von `x` erneut und führen Sie den Codeblock aus. Was passiert, wenn `x` Null ist?\n:::\n\n# Funktionen\n\nIn R kann man Funktionen selber definieren. Dies ist einerseits nützlich, wenn man etwas berechnen will, es in R aber dafür keine Funktion gibt; andererseits sind Funktion nützlich, um Code zu strukturieren und zu modularisieren. Dies bedeutet, dass man Schritte in einer Funktion zusammenfassen kann, und diese dann testen und wiederverwenden kann. Eine Daumenregel ist: Wenn Sie einen Codeblock mehr als einmal verwenden, dann sollten Sie ihn in eine Funktion packen.\n\n\nEine Funktion besteht aus einem Funktionsnamen, einem oder mehreren Argumenten und einem Funktionskörper. Der Funktionskörper ist der Code, der ausgeführt wird, wenn die Funktion aufgerufen wird. Der Funktionsname ist der Name, unter dem die Funktion in R bekannt ist. Die Argumente sind Werte, welche die Funktion als Input erhält. Funktionen werden mit der Funktion `function()` definiert.\n\n\nWir definieren nun eine Funktion, welche irgendeine eine Zahl `x` \nals Input erhält und die Zahl `x + 1` als Output zurückgibt.\n\n`add_one` ist der Funktionsname. `x` ist das beliebige Argument. Innerhalb der geschweiften Klammern `{}` ist der Funktionskörper, d.h. der Code, welcher ausgeführt wird, wenn die Funktion aufgerufen wird.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_one <- function(x) {\n  x + 1\n}\n```\n:::\n\n\nDieser Code muss in R einmal ausgeführt werden, damit die Funktion `add_one` definiert wird. Danach kann \n`add_one` aufgerufen werden.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_one(30)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 31\n```\n:::\n:::\n\n\nWas passiert aber nun, wenn wir `add_one` mit einem String aufrufen? Wir erhalten einen Fehler, da wir die Funktion `add_one` nicht mit einem String aufrufen können. Wir können die Funktion `add_one` nur mit Zahlen aufrufen.\n\n:::{.callout-important}\nWas passiert, wenn sie die Funktion mit einem String aufrufen?\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_one(\"Hello\")\n```\n:::\n\n:::\n\nEs wäre sinnvoll, den Input zu prüfen, bevor die Funktion ausgeführt wird. Dies bedeutet, dass wir mit der Funktion `is.numeric()` prüfen, ob der Input eine Zahl ist. Falls der Input keine Zahl ist, dann wollen wir eine Fehlermeldung ausgeben. Falls der Input eine Zahl ist, dann wollen wir die Funktion `add_one` ausführen. Wir können dies mit `if` und `else` tun.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_one <- function(x) {\n  if (is.numeric(x)) {\n    x + 1\n  } else {\n    print(\"Hey, this only works if x is a number! Try again!\")\n  }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_one(\"Hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Hey, this only works if x is a number! Try again!\"\n```\n:::\n:::\n\n\n\n\n\n# Loops    \n\nMit Loops können wir über Vektoren oder Listen iterieren. Dies bedeutet, dass wir einen oder mehrere Schritte in einem Codeblock für jedes Element eines Vektors oder einer Liste ausführen können. Wir können Loops mit `for` definieren. \n\nDer Codeblock wird in geschweiften Klammern `{}` eingeschlossen. Der Codeblock wird für jedes Element des Vektors oder der Liste ausgeführt. In einer `for`-Schleife brauchen wir eine spezielle Variable, welche bei jedem Durchlauf des Loops den Wert des aktuellen Elements erhält. Diese Variable nennt man eine Iterationsvariable; diese wird oft `i` genannt (dies ist aber keine Vorschrift, wir können genausogut auch andere Namen verwenden).\n\n\n\nAls erstes Beispiel wollen wir die Namen einzelner Früchte aus einem Vektor ausgeben. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfruits <- c(\"apple\", \"banana\", \"orange\", \"cherry\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (fruit in fruits) {\n    print(fruit)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"apple\"\n[1] \"banana\"\n[1] \"orange\"\n[1] \"cherry\"\n```\n:::\n:::\n\n\nAnstatt die Elemente direkt zu verwenden, macht es manchmal Sinn, über die Indizes zu iterieren. Wir können dies mit der Funktion `seq_along()` tun. `seq_along()` gibt eine Folge von Zahlen zurück, welche die Indizes der Elemente des Vektors repräsentieren. \n\n\n:::{.callout-tip}\n## Iteration: Elemente oder Indizes?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_three_letters <- c(\"a\", \"b\", \"c\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (letter in first_three_letters) {\n  print(letter)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in seq_along(first_three_letters)) {\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n```\n:::\n:::\n\n\nWenn wir die trotz Iteration über Indizes die Elemente haben wollen, müssen wir den Vektor indizieren.\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in seq_along(first_three_letters)) {\n  print(first_three_letters[i])\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n```\n:::\n:::\n\n:::\n\nMit dem Früchte-Beispiel:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in seq_along(fruits)) {\n  print(fruits[i])\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"apple\"\n[1] \"banana\"\n[1] \"orange\"\n[1] \"cherry\"\n```\n:::\n:::\n\n\n\n\n\n\nWir können auch eine deskriptive Nachricht ausgeben. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (fruit in fruits) {\n  print(paste(fruit, \"is a fruit\"))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"apple is a fruit\"\n[1] \"banana is a fruit\"\n[1] \"orange is a fruit\"\n[1] \"cherry is a fruit\"\n```\n:::\n:::\n\n\n\nNun können wir einige der Konzepte kombinieren. Wir wollen nun jedes Element einer Liste testen, ob es eine Frucht oder ein Gemüse ist. Falls es eine Frucht ist, wollen wir die Message \"is a fruit\" ausgeben. Falls es ein Gemüse ist, wollen wir die Message \"is a vegetable\" ausgeben. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfruits <- c(\"apple\", \"banana\", \"orange\", \"cherry\")\nvegetables <- c(\"carrot\", \"potato\", \"tomato\", \"cucumber\")\n```\n:::\n\n\n\n\nWir erstellen nun eine zufällige Liste von Früchten und Gemüse. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(589)\nfoods <- sample(c(sample(fruits, 3), sample(vegetables, 3)))\nfoods\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"cucumber\" \"carrot\"   \"orange\"   \"cherry\"   \"banana\"   \"tomato\"  \n```\n:::\n:::\n\n\nWie können wir nun feststellen, ob ein Element in der Liste eine Frucht oder ein Gemüse ist? Wir können dies z.B. mit `%in%` tun. `%in%` prüft, ob ein Element in einem Vektor enthalten ist. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"apple\" %in% fruits\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (food in foods) {\n    if (food %in% fruits) {\n        print(paste(food, \"is a fruit\"))\n    } else if (food %in% vegetables) {\n        print(paste(food, \"is a vegetable\"))\n    } else {\n        print(paste(food, \"is neither fruit nor vegetable\"))\n    }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"cucumber is a vegetable\"\n[1] \"carrot is a vegetable\"\n[1] \"orange is a fruit\"\n[1] \"cherry is a fruit\"\n[1] \"banana is a fruit\"\n[1] \"tomato is a vegetable\"\n```\n:::\n:::\n\n\n:::{.callout-important}\nWas passiert, wenn ein Element weder Frucht noch Gemüse ist?\n:::\n\nIm obigen Code verwenden wir die Funktion `paste()` mehrmals. Es könnte Sinn machen, eine eigene Funktion definieren. Wir verwenden die Funktion `stopifnot()`, um zu prüfen, ob das Argument ein String ist. Falls dies nicht der Fall ist, wird die Funktion mit einer passenden Fehlermeldung abgebrochen. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhat_is <- function(x) {\n    stopifnot(is.character(x))\n\n    if (x %in% fruits) {\n        paste(x, \"is a fruit\") |> print()\n    } else if (x %in% vegetables) {\n        paste(x, \"is a vegetable\") |> print()\n    } else {\n        paste(x, \"is neither fruit nor vegetable\") |> print()\n    }\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (food in foods) {\n    what_is(food)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"cucumber is a vegetable\"\n[1] \"carrot is a vegetable\"\n[1] \"orange is a fruit\"\n[1] \"cherry is a fruit\"\n[1] \"banana is a fruit\"\n[1] \"tomato is a vegetable\"\n```\n:::\n:::\n\n\n\n\n\n## Alternativen zu `for`-Loops\n\nEs gibt in R mehrere Möglichkeiten, um über Vektoren oder Listen zu iterieren, ohne dabei explizite  `for`-Loops zu schreiben. Dies hat den Vorteil, dass der Code kürzer und übersichtlicher wird. \n\n\n### `lapply` und `sapply`\n\n`lapply` und `sapply` sind zwei Funktionen, welche über Listen iterieren. `lapply` und `sapply` sind sehr ähnlich. `lapply` gibt eine Liste zurück, während `sapply` versucht den output zu vereinfachen (Vektor, Matrix).\n\n\nAls Beispiel wollen wir jedes Element eines Vektors verdoppeln (dies kann in R auch einfacher gemacht werden, aber dies ist nur ein Übungsbeispiel). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- c(1, 2, 3, 4, 5)\n```\n:::\n\n\n\nMit `for` können wir dies wie folgt tun.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (number in numbers) {\n    print(number * 2)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n[1] 4\n[1] 6\n[1] 8\n[1] 10\n```\n:::\n:::\n\n\n\nMit `lapply` und `sapply` haben wir zwei Möglichkeiten. Wir können entweder eine anonyme Funktion definieren, oder wir können eine Funktion zuerst definieren, und dann verwenden. \n\n`\\(x) x * 2` definiert eine sogenannte anonyme Funktion. Diese Funktion nimmt ein Argument `x` und multipliziert es mit 2, erhält aber keinen eigenen Namen. Folglich können wir diese Funktion nicht wiederverwenden. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(numbers, \\(x) x * 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 2\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 6\n\n[[4]]\n[1] 8\n\n[[5]]\n[1] 10\n```\n:::\n:::\n\n\n\nMit einer Funktion, die wir zuerst definieren, sieht unser Beispiel so aus.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndouble <- function(x) {\n    x * 2\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(numbers, double)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 2\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 6\n\n[[4]]\n[1] 8\n\n[[5]]\n[1] 10\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(numbers, double)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  4  6  8 10\n```\n:::\n:::\n\n\n\n\n\n### `map`\nEine weitere Möglichkeit, über Listen zu iterieren, ist die Funktion `map`. `map` ist eine Funktion aus dem Paket `purrr` (wird automatisch geladen, wenn `tidyverse` geladen wird). `map` gibt immer eine Liste zurück. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Paket 'ggplot2' wurde unter R Version 4.2.3 erstellt\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Paket 'tibble' wurde unter R Version 4.2.3 erstellt\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Paket 'dplyr' wurde unter R Version 4.2.3 erstellt\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.1     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers |> map(double)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 2\n\n[[2]]\n[1] 4\n\n[[3]]\n[1] 6\n\n[[4]]\n[1] 8\n\n[[5]]\n[1] 10\n```\n:::\n:::\n\n\nWenn wir als Output einen Vektor haben wollen, müssen wir die Funktion `unlist()` verwenden. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers |> map(double) |> unlist()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  2  4  6  8 10\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}